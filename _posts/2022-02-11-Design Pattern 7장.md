---
title: "[Book]Design Pattern 7장"
categories: book
toc: true
toc_label: "목차"
toc_icon: "cog"
---

## 어댑터 패턴

### 클라이언트에서 어댑터를 사용하는 방법

1. 클라이언트에서 타켓 인터페이스를 사용하여 메소드를 호출함으로써 어댑터에 요청을 합니다.
2. 어댑터에서는 어댑티 인터페이스를 사용하여 그 요청을 어댑티에 대한 (하나 이상의) 메소드 호출로 변환합니다. 
3. 클라이언트에서는 호출 결과를 받긴 하지만 중간에 어댑터가 껴 있는지는 전혀 알지 못합니다.

### Duck을 Turkey로 변환해주는 어댑터 만들기

```java
public class DuckAdapter implements Turkey {
	Duck duck;
	
	public DuckAdapter(Duck duck) {
		this. duck = duck;
	}

	public void gobble(){
		duck.quack();
	}
	
	public void fly() {
		duck.fly();
	}
}
```

### 정의

- 한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환합니다. 어댑터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있습니다.

### 객체와 클래스 어댑터

- 어댑터에는 두 종류가 있다. 객체 어댑터와 클래스 어댑터
- 클래스 어댑터를 쓰려면 다중 상속이 필요한데, 자바는 다중 상속이 안되기 때문에 책에서 심도있게 다루지는 않는다.

### 데코레이터, 어댑터, 퍼사드 패턴의 차이

- 데코레이터 패턴 : 인터페이스는 바꾸지 않고 책임(기능)만 추가
- 어댑터 패턴 : 한 인터페이스를 다른 인터페이스로 변환
- 퍼사드 패턴 : 인터페이스를 간단하게 바꿈

## 퍼사드 패턴

- 퍼사드는 인터페이스를 단순화시킬 뿐 아니라 클라이언트와 구성요소들로 이루어진 서브시스템을 분리시키는 역할도 합니다.
- 퍼사드와 어댑터는 모두 여러개의 클래스를 감쌀 수 잇습니다. 하지만 퍼사드는 인터페이스를 단순화시키기 위한 용도로 쓰이는 반면, 어댑터는 인터페이스를 다른 인터페이스로 변환하기 위한 용도로 쓰입니다.

### 정의

- 어떤 서브시스템의 일련의 인터페이스에 대한 통합된 인터페이스를 제공합니다. 퍼사드에서 고수준 인터페이스를 정의하기 때문에 서브시스템을 더 쉽게 사용할 수 있습니다.

## 디자인 원칙

- 최소 지식 원칙 - 정말 친한 친구하고만 얘기하라

→ 시스템을 디자인 할 때, 어떤 객체든 그 객체와 상호작용을 하는 클래스의 개수에 주의해야 하며, 그런 객체들과 어떤 식으로 상호작용을 하는지에도 주의를 기울여야 한다는 뜻.

### 어떻게 친구를 만들이 않으면서 다른 객체에 영향을 줄 수 있을까?

- 어떤 메소드에서든지 다음 네 종류의 객체의 메소드만을 호출하면 됩니다.
    1. 객체 자체
    2. 메소드에 매개변수로 전달된 객체
    3. 그 메소드에서 생성하거나 인스턴스를 만든 객체
    4. 그 객체에 속하는 구성요소