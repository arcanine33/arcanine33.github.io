--- 
title: "[Book]Clean Architecture 2부"
categories: book
toc: true
toc_label: "목차"
toc_icon: "cog"
---

## 구조적 프로그래밍

- 순차(sequence), 분기(selection), 반복(iteration) 세 가지 구조만으로 표현 할 수 있다.
- goto문이 필요없음을 알리고, 이는 컴퓨터 언어가 진화하면서 거의 사라졌다.
- 구조적 프로그래밍을 통해 모듈을 증명가능한 더 작은 단위로 분해할 수 있게 되었고, 결국 모듈을 기능적으로 분해할 수 있음을 뜻했다.
- 프로그램 관점에서 정리에 대한 유클리드 계층구조는 끝내 만들어지지 않았다.

## 객체 지향 프로그래밍

- Object-Oriented
- OO의 본질 : 캡슐화(encapsulation), 상속(inheritance), 다형성(polymorphism)

### 캡슐화?

- 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있다.
- 구분선 바깥에서 데이터는 은닉되고, 일부 함수만이 외부에 노출된다.
- OO언어에서 클래스의 private멤버데이터와 public멤버함수로 표현된다.

### 상속?

### 다형성?

- 플러그인 아키텍처는 입출력 장치 독립성을 지원하기 위해 만들어졌고, 등장 이후 거의 모든 운영체제에서 구현되었다.

### 의존성 역전(Dependency Inversion)

- OO언어가 다형성을 안전하고 편리하게 제공한다는 사실은 **소스코드 의존성을 어디에서든 역전 시킬 수 있다는 뜻**이다.
- OO언어로 개발된 시스템을 다루는 SW 아키텍트는 시스템의 소스 코드 의존성 전부에 대해 방향을 결정할 수 있는 절대적인 권한을 갖는다.
- 즉, 소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한되지 않는다. 호출하는 모듈이든 아니면 호출 받는 모듈이든 관계없이 소프트웨어 아키텍트는 소스 코드 의존성을 원하는 방향으로 설정 할 수 있다.
- 업무 규칙을(Business Logic) UI와 DB와는 독립적으로 배포할 수 있다. UI나 DB에서 발생한 변경사항은 업무 규칙에 일절 영향을 미치지 않는다. 즉, 개별적이며 독립적으로 배포 가능하다.
- **배포 독립성(Independent deployability) :** 특정 컴포넌트의 소스코드가 변경되면, 해당 코드가 포함된 컴포넌트만 다시 배포하면 된다.
- **개발 독립성(Independent Developability) :** 시스템의 모듈을 독립적으로 배포할 수 있게 되면, 서로 다른 팀에서 각 모듈을 독립적으로 개발할 수 있다.

## 함수형 프로그래밍

- 함수형 언어에서 변수는 변경되지 않는다.

### 불변성과 아키텍쳐

- 경합 조건, 교착상태 조건, 동시 업데이트 등의 문제는 모두 가변 변수로 인해 발생한다.
- 저장공간이 무한하고 프로세서의 속도가 무한히 빠르다면 불변성이 가능할지도?

### 가변성의 분리

- 불변 컴포넌트와 가변 컴포넌트를 분리해야한다. 그리고 가변 변수들을 보호하는 적절한 수단을 동원해 뒷받침해야 한다.
- 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야 한다.

### 이벤트 소싱

- 이벤트 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략이다. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.
- 소스코드 버전 관리 시스템이 이와 같이 동작한다.

## 결론

- 구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율이다.
- 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율이다.
- 함수형 프로그래밍은 변수 할당에 부과되는 규율이다.