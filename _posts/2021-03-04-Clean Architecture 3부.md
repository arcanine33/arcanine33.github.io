---
title: "[Book]Clean Architecture 3부"
categories: book
toc: true
toc_label: "목차"
toc_icon: "cog"
---

- 좋은 벽돌로 좋은 아키텍쳐를 정의하는 원칙 : SOLID
- SOLID 목적
    - 변경에 유연하다.
    - 이해하기 쉽다.
    - 많은 SW시스템에 사용될 수 있는 컴포넌트의 기반이 된다.
1. SRP(단일 책임 원칙 [Single Reponsiblity Principle])
    - 콘웨이(Conway) 법칙에 따른 따름정리 : SW시스템이 가질 수 있는 최적의 구조는 시스템을 만드는 조직의 사회적 구조에 커다란 영향을 받는다. 따라서 각 SW 모듈은 변경의 이유가 하나여야만 한다.
2. OCP(개방-폐쇄 원칙[Open-Closed Principle])
    - 기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 SW시스템을 쉽게 변경할 수 있어야 한다.
3. LSP(리스코프 치환 원칙[Liskov Substitution Principle])
    - 상호 대체 가능한 구성요소를 이용해 SW 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다.
4. ISP(인터페이스 분리 원칙[Interface Segregation Principle])
    - SW설계자는 사용하지 않은 것에 의존하지 않아야 한다.
5. DIP(의존성 역전 원칙[Dependency Inversion Principle])
    - 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안 된다. 대신 세부사항이 정책에 의존해야 한다.

## SRP : 단일 책임 원칙

하나의 모듈은 하나의, 오직 하나의 Actor에 대해서만 책임져야 한다. (Actor : 해당 변경을 요청하는 한 명 이상의 사람들)

- 징후1 : 우발적 중복
- 징후2 : 병합
- 해결책 : 퍼사드 패턴
- 결론 : 단일 책임 원칙은 메서드와 클래스 수준의 원칙이다. 하지만 컴포넌트 수준에서는 '공통 폐쇄 원칙'이 되며, 아키텍처 수준에서는 아키텍처 경계의 생성을 책임지는 변경의 축이 된다.

## OCP : 개방-폐쇄 원칙

- 소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
- OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향ㅇㄹ 받지 않도록 하는데 있다. 이러한 목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.

## LSP : 리스코프 치환 원칙

- S타입 객체 o1 각각에 대응하는 T타입 객체 o2가 있고, T타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위 타입이다.
- 상속을 사용하도록 가이드 하기
- 결론 : LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다. 치환 가능성을 조금이라도 위배하면, 시스템 아키텍쳐가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있기 때문이다.

## ISP : 인터페이스 분리 원칙

- 결론 : 불필요한 짐을 실은 무언가에 의존하면 예상치도 못한 문제에 빠진다는 사실이다.

## DIP : 의존성 역전 원칙

- 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템
- **변동성이 큰 구체 클래스를 참조하지 말라.** 대신 추상 인터페이스를 참조하라.
- **변동성이 큰 구체 클래스로부터 파생하지 말라.**
- **구체함수를 오버라이드 하지 마라.** 차라리 추상 함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현해야 한다.
- **구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.**
- 자바 등에서 바람직하지 못한 의존성을 처리할 때, 추상 팩토리를 사용하곤 한다.
- 결론 : DIP는 아키텍쳐 다이어그램에서 가장 눈에 드러나는 원칙이 될 것이다.